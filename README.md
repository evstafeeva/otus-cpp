
# О SpaceExpansion
## Концепция
Большинство стратегических игр реального времени требуют от игроков работать одновременно в двух плоскостях:
  1. **макроконтроль** - это плоскость в которой игрок принимает стратегические решения; она требует больше аналитической работы, способности к адаптации и изменении стратегии; большую часть игры игрок работает в этой плоскости;
  2. **микроконтроль** - в этой плоскости игрок оказывается лишь в определённые относительно короткие промежутки игры, например, при боевом столкновении с армией противника; она требует от игрока хорошей реакции, быстрого анализа ситуации и точных механических действий.

С макроконтролем человек обычно справляется лучше компьютерных программ, в то время как в микроконтроле человек не способен состязаться с компьютерным оппонентом.

Существуют классические стратегические игры, где борьба ведётся между двумя игроками "Человек - Человек". Например, StarCraft 2.
Существуют и менее популярные игры для программистов, суть которых сводится к тому, что игроки пишут программу, управляющую игровым миром, а затем эти программы соревнуются друг с другом без участия человека.

Идея SpaceExpansion - объединение двух этих концепций.

На сервере реализуется игровой мир и вся игровая механика. Сервер предоставляет игрокам открытый протокол для управления их юнитами и получения информации об игровом мире. Игроки реализуют собственный игровой клиент, причем:
1. для решения задач, требующих сложного микроконтроля, игроки разрабатывают собственные алгоритмы;
2. решение стратегических задач игроки будут брать на себя.

Таким образом, игроком будет выступать **союз человека и написанного им ПО**.
Разумеется, человек может попытаться самостоятельно решать задачи микроконтроля, но из-за сложности игрового мира он будет делать это крайне неэффективно, что приведёт к быстрому поражению.
Не исключено, что игрок сможет написать ИИ, решающий не только тактические, но и стратегические задачи. Чтож, имеет право, но это будет не просто, и, скорее всего, живые игроки быстро найдут у него слабые места.

## Игровой мир
Действие происходит в космосе. Каждая команда получает командный центр, утрата которого выводит команду из игры.
В игровом мире действуют законы Ньютоновой механики - крупные небесные тела притягивают к себе все остальные объекты игрового мира.
В командном центре можно строить корабли трёх видов:
  * Miner - для добычи ресурсов на астероидах;
  * Probe - маленький корабль для сканирования космического пространства;
  * Frigate - боевой корабль с ракетными установками на борту.

На кораблях устанавливаются **модули** - ключевые элементы игры. Каждый модуль имеет простой интерфейс для управления и отдавая команды этим модулям игрок может получать информацию об игровом мире, либо воздействовать на него.

Например, модуль "Двигатель" (engine) устанавливается на корабле. Его интерфейс позволяет установить вектор тяги двигателя. Когда игрок устанавливает вектор тяги, скорость корабля, на котором установлен двигатель, начинает изменяться в соответствии с законами Ньютоновой механики.
Другой пример: модуль Scanner. Он по запросу от игрока сканирует пространство в некотором радиусе и возвращает игроку результаты сканирования.
В игре будет реализован набор различных модулей, с помощью которых игрок сможет решать все необходимые задачи. Конечно, чем больше модулей, тем интереснее и разнообразнее игровая механика, но, с другой стороны, тем выше порог вхождения в игру. Поэтому в первой версии игры модулей будет минимальное количество.

**Примеры микро- и макро-контроля:**
Игрок решает, что ему необходимо нарастить добычу определённых ресурсов. Он строит дополнительные Miner'ы и отдаёт им приказ лететь к астероиду и добывать на них ресурс. Это примеры решения из плоскости макроконтроля.
Для того, чтобы подлететь к астероиду, кораблю нужно совершить ряд манёвров для сближения с астероидом и выравнивания скоростей. Это потребует управлять двигателями. Сделать это вручную и "на глазок" крайне сложно и не эффективно, особенно в гравитационном поле планеты. А если корабль не один, а их 20? Соответственно, нужно написать алгоритмы, которые решают задачу навигации в пространстве, грамотно управляя двигателями.

Другой пример - сбивать вражеские ракеты. Здесь отсутствует плоскость макроконтроля, т.к. совершенно очевидно, что корабль должен уничтожать приближающиеся к нему ракеты и, желательно, без участия человека. Поэтому игрок пишет алгоритм, который сканирует окружающее пространство, обнаруживает потенциально опасные ракеты, выпускает и наводит на неё противоракету. Сделать это вручную так же не представляется возможным.

## Протокол и релизы
На данный момент, предусмотрен план на 10 релизов игры, начиная с версии 0.1 и заканчивая версией 1.0. Каждый релиз - это законченная и готовая к работе версия сервера, для которой игроки могут писать свои клиенты. Она сопровождается описанием интерфейса и доступных модулей. Каждый следующий релиз будет добавлять в игру новые модули, а вместе с ними и новую игровую механику.


# Реализация
## Требование
Несколько главных требования к реализации:
  1. добиться эффективного горизонтального масштабирования решения по ядрам/процессорам;
  2.  добиться максимальной утилизации вычислительных ресурсов;
  3.  внутриигровое время должно протекать в соответствии с реальным временем.

Из п. 2 и 3 логически вытекает необходимость динамического изменения точности расчётов игрового мира, чтобы при низких нагрузках (мало объектов и событий) точность была наибольшей, а при высоких нагрузках точность снижалась в угоду производительности.

## Идея реализации
### Логики
Вся игровая механика будет разбита на независимые части - **логики (AbstractLogic)**. Каждая логика решает определённую задачу, например:
  * Логика **Ньютоновой механики** проходит по всем физическим объектам игрового мира и для каждого объекта:
    * вычисляет равнодействующую сил (от гравитации, двигателей и т.п.);
    * вычисляет текущий вектор ускорения;
    * в зависимости от текущих векторов скорости и ускорения перемещает объект в игровом мире и корректирует его вектор скорости.
  * Логика **сетевого модуля** опрашивает все сокеты, кодирует и отправляет все сообщения из буфера отправки, а так же принимает, декодирует и передаёт на обработку все сообщения из буфера приёма;
  * и т.п.

Логики работают поочерёдно, поэтому для них вводится требование **квантования** т.е. каждая логика за один запуск проводит лишь **конечный и минимально необходимый** объём работы. Например, логика Ньютоновой Механики лишь **однократно** проходит по всем объектам и перемещает их (на указанный внутриигровой временной квант). Логика сетевого модуля лишь **одноратно** проходит по всем сокетам и выполняет операции записи/чтения там, где это необходимо.

Каждая логика может быть разбита на несколько **стадий**. Например, логика Ньютоновой Механики может быть разделена на две стадии:
  1. расчёт равнодействующих и ускорений;
  2. перемещение объектов.

Логики проектируются и разбиваются на стадии таким образом, чтобы:
  1. все стадии можно было выполнять **многопоточно**;
  2. нагрузка по потокам была распределена максимально **равномерно**;
  3. минимизировать необходимость **синхронизации** между потоками.

Для того, чтобы упростить задачу написания логик и добиться максимальной эффективности в реализации стадий, вводится **гарания**, что во время выполнения той или иной стадии некоторой логики **никакой другой код НЕ выполняется**.

## Конвеер

Все логики будут объединятся в **конвеер (Conveyor)**. Конвеер реализует последовательный проход по логикам и запуск их параллельного выполнения в нескольких потоках. Выполнение всех логик и их стадий разделены между собой **барьерами**. Таким образом, до тех пор пока все потоки не закончат обработку предыдущей стадии, ни один поток не перейдёт к выполнению следующей стадии. Управление переходом между логиками и некоторые др. служебные информации выполняет **master-поток**.

Просчёт игрового мира будет разбит на **такты**. Такт - это однократный проход по конвееру. Единственная характеристика каждого такта - его длительность по внутриигровому времени (т.е. временной квант).

На уровне конвеера можно реализовать требование к **динамическому изменению точности расчёта** игрового мира. Конвеер перед запуском каждого следующего такта вычисляет "отставание" игрового времени от реального и, в зависимости от отставания, вычисляет квант внутриигрового времени, который должен быть обработан в следующем такте. Чем меньше реального времени требуется на обработку каждого такта, тем меньший квант игрового времени назначается каждому такту, благодаря чему увеличивается точность расчётов игрового мира. И наоборот.
